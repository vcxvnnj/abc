<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>éš”ç©ºå†™å­— â€” MediaPipe æ‰‹åŠ¿äº¤äº’ç¤ºä¾‹</title>
<style>
  :root{
    --panel-bg: rgba(20,20,30,0.9);
    --panel-accent: #6ee7b7;
    --ui-radius: 12px;
  }
  html,body{height:100%;margin:0;background:#0b1020;color:#fff;font-family:system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
  #container{position:relative;height:100vh;overflow:hidden;}
  video#input_video{display:none;transform:scaleX(-1);} /* mirror hidden */
  canvas{position:absolute;left:0;top:0;touch-action:none;}
  #ui-panel{
    position:absolute;
    transform:translate(-50%,-120%);
    min-width:220px;
    background:var(--panel-bg);
    border-radius:var(--ui-radius);
    padding:10px;
    display:none;
    box-shadow:0 6px 24px rgba(0,0,0,0.6);
    backdrop-filter: blur(6px);
    z-index:20;
    user-select:none;
  }
  .row{display:flex;gap:8px;align-items:center;margin-bottom:8px;}
  .tool{
    background: rgba(255,255,255,0.06);
    border-radius:10px;padding:8px;min-width:44px;text-align:center;cursor:pointer;
    font-size:13px;
  }
  .tool.selected{outline:2px solid var(--panel-accent);box-shadow:0 4px 12px rgba(110,231,183,0.12)}
  .color-swatch{width:32px;height:32px;border-radius:8px;cursor:pointer;border:2px solid rgba(255,255,255,0.06)}
  #sizeValue{display:inline-block;width:36px;text-align:right;margin-left:6px}
  #help {position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.35);padding:8px 12px;border-radius:10px;font-size:13px}
  #clearBtn{background:#ef4444;padding:6px 10px;border-radius:8px;cursor:pointer}
  #status{position:absolute;right:12px;bottom:12px;background:rgba(255,255,255,0.06);padding:8px 12px;border-radius:10px;font-size:13px}
  /* particle style is drawn via canvas */
</style>
</head>
<body>
<div id="container">
  <video id="input_video" autoplay playsinline></video>
  <!-- canvas: drawing layer (persistent strokes) -->
  <canvas id="drawCanvas"></canvas>
  <!-- canvas: overlay for live drawing / UI highlights / gestures -->
  <canvas id="overlay"></canvas>

  <div id="ui-panel" aria-hidden="true">
    <div class="row" style="justify-content:space-between">
      <div style="font-weight:600">å·¥å…·</div>
      <div id="clearBtn">é‡ç½®</div>
    </div>
    <div class="row" id="toolsRow">
      <div class="tool" data-tool="pen" id="tool-pen">âœï¸ ç¬”</div>
      <div class="tool" data-tool="eraser" id="tool-eraser">ğŸ§½ æ©¡çš®</div>
    </div>
    <div class="row">
      <div style="font-size:12px">é¢œè‰²</div>
      <div style="display:flex;gap:6px">
        <div class="color-swatch" data-color="#ffffff" style="background:#ffffff"></div>
        <div class="color-swatch" data-color="#ff6b6b" style="background:#ff6b6b"></div>
        <div class="color-swatch" data-color="#6ee7b7" style="background:#6ee7b7"></div>
        <div class="color-swatch" data-color="#60a5fa" style="background:#60a5fa"></div>
        <div class="color-swatch" data-color="#facc15" style="background:#facc15"></div>
      </div>
    </div>
    <div class="row" style="align-items:center">
      <div style="font-size:12px">ç¬”ç²—</div>
      <input id="sizeRange" type="range" min="1" max="40" value="6" style="flex:1">
      <div id="sizeValue">6</div>
    </div>
    <div style="font-size:12px;color:#bbb;margin-top:6px">æ“ä½œæç¤ºï¼šé£ŸæŒ‡+æ‹‡æŒ‡åˆæ‹¢å†™å­—ï¼›åŒæ‰‹é£ŸæŒ‡ç¼©æ”¾ï¼›é£ŸæŒ‡+ä¸­æŒ‡å±•å¼€è§¦å‘æ¶ˆæ•£</div>
  </div>

  <div id="help">å°†æ‰‹æŒæ‰“å¼€ä»¥å‘¼å‡ºé¢æ¿ âœ‹</div>
  <div id="status">çŠ¶æ€ï¼šç­‰å¾…æ‰‹åŠ¿</div>
</div>

<!-- MediaPipe Hands and utilities -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script>
/*
  å•æ–‡ä»¶å®ç°ï¼šMediaPipe Hands + Canvas ç»˜ç”» + æ‰‹åŠ¿æ§åˆ¶ UI
  ä½œè€…ï¼šChatGPTï¼ˆç¤ºä¾‹ï¼‰
*/

/* ---------- å…¨å±€å…ƒç´  ---------- */
const video = document.getElementById('input_video');
const overlay = document.getElementById('overlay');
const drawCanvas = document.getElementById('drawCanvas');
const ctxOverlay = overlay.getContext('2d');
const ctxDraw = drawCanvas.getContext('2d');

const panel = document.getElementById('ui-panel');
const statusEl = document.getElementById('status');
const helpEl = document.getElementById('help');

const toolPen = document.getElementById('tool-pen');
const toolEraser = document.getElementById('tool-eraser');
const colorSwatches = document.querySelectorAll('.color-swatch');
const sizeRange = document.getElementById('sizeRange');
const sizeValue = document.getElementById('sizeValue');
const clearBtn = document.getElementById('clearBtn');

/* ---------- çŠ¶æ€ä¸è®¾ç½® ---------- */
let selectedTool = 'pen';
let selectedColor = '#ffffff';
let penSize = 6;

let panelVisible = false;
let lastPanelPos = {x:0,y:0};
let selectionHoverStart = null;
let hoverTarget = null;

let drawing = false; // å½“å‰æ­£ç”¨æåˆç”»çº¿
let lastDrawPoint = null;

// Keep persistent strokes in drawCanvas (as image). We'll apply global transform for zoom.
let globalScale = 1.0;
let globalOffset = {x:0,y:0}; // not used heavily; center scaling around canvas center for simplicity
let twoHandScaling = {active:false, startDist:0, startScale:1.0};

// particle for disperse
let particles = [];
let dispersing = false;

/* ---------- Helpers: resize canvases to video size ---------- */
function resizeCanvasesToVideo() {
  const w = video.videoWidth;
  const h = video.videoHeight;
  if (!w || !h) return;
  [overlay, drawCanvas].forEach(c=>{
    c.width = w;
    c.height = h;
    c.style.width = video.style.width || (w + 'px');
    c.style.height = video.style.height || (h + 'px');
  });
  // scale overlay css to fill container
  overlay.style.width = '100%';
  overlay.style.height = '100%';
  drawCanvas.style.width = '100%';
  drawCanvas.style.height = '100%';
}

/* ---------- ç®€å•å‡ ä½• ---------- */
function dist(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function lerp(a,b,t){return a + (b-a)*t;}

/* ---------- æ‰‹æŒ‡/æ‰‹æŒåˆ¤å®šå‡½æ•°ï¼ˆç»éªŒé˜ˆå€¼ï¼‰ ---------- */
/*
MediaPipe landmarks indexes:
0: wrist
1: thumb_cmc
2: thumb_mcp
3: thumb_ip
4: thumb_tip
5: index_finger_mcp
6: index_finger_pip
7: index_finger_dip
8: index_finger_tip
9: middle_finger_mcp
10: middle_finger_pip
11: middle_finger_dip
12: middle_finger_tip
13: ring_finger_mcp
14: ring_finger_pip
15: ring_finger_dip
16: ring_finger_tip
17: pinky_mcp
18: pinky_pip
19: pinky_dip
20: pinky_tip
*/
function fingersExtended(landmarks){
  // returns {thumb:boolean, index, middle, ring, pinky}
  // For index/middle/ring/pinky: tip.y < pip.y usually means extended (camera flipped laterally)
  const res = {};
  try{
    res.index = landmarks[8].y < landmarks[6].y;
    res.middle = landmarks[12].y < landmarks[10].y;
    res.ring = landmarks[16].y < landmarks[14].y;
    res.pinky = landmarks[20].y < landmarks[18].y;
    // thumb: compare tip.x relative to mcp (handedness unknown). We'll use tip.x vs ip.x - if far it is extended
    res.thumb = Math.abs(landmarks[4].x - landmarks[2].x) > 0.04;
  }catch(e){
    return {thumb:false,index:false,middle:false,ring:false,pinky:false};
  }
  return res;
}

function isPalmOpen(landmarks){
  // consider palm open if >=4 fingers extended
  const f = fingersExtended(landmarks);
  const count = [f.thumb,f.index,f.middle,f.ring,f.pinky].filter(Boolean).length;
  return count >= 4;
}

function isPinch(landmarks, videoW, videoH){
  // pinch if distance between index tip (8) and thumb tip (4) small
  const d = Math.hypot((landmarks[8].x-landmarks[4].x)*videoW,(landmarks[8].y-landmarks[4].y)*videoH);
  // threshold relative to diagonal
  const diag = Math.hypot(videoW, videoH);
  return d < diag * 0.045; // empirical
}

function isIndexAndMiddleOpen(landmarks){
  const f = fingersExtended(landmarks);
  // both index and middle extended, and others not necessarily
  return f.index && f.middle;
}

/* ---------- UI helpers ---------- */
function showPanelAt(x,y){
  panel.style.left = (x * 100) + '%';
  panel.style.top = (y * 100) + '%';
  panel.style.display = 'block';
  panel.setAttribute('aria-hidden','false');
  panelVisible = true;
}
function hidePanel(){
  panel.style.display = 'none';
  panel.setAttribute('aria-hidden','true');
  panelVisible = false;
  selectionHoverStart = null;
  hoverTarget = null;
}

/* ---------- UI selections (mouse-free) ---------- */
function updatePanelHover(ix,iy,videoW,videoH){
  // ix,iy are normalized (0..1) coord of index finger (mirrored)
  // transform to panel DOM coordinates
  const rect = panel.getBoundingClientRect();
  if (rect.width === 0) return;
  // map normalized coordinates to container pixels
  const containerRect = document.getElementById('container').getBoundingClientRect();
  const px = ix * containerRect.width;
  const py = iy * containerRect.height;
  // check children hit
  const elems = [...panel.querySelectorAll('.tool,.color-swatch,#sizeRange,#clearBtn')];
  let found = null;
  elems.forEach(el=>{
    const r = el.getBoundingClientRect();
    if (px >= r.left && px <= r.right && py >= r.top && py <= r.bottom){
      found = el;
    }
  });
  if (found){
    if (hoverTarget !== found){
      hoverTarget = found;
      selectionHoverStart = performance.now();
      // visual highlight
      elems.forEach(e=>e.classList && e.classList.remove('selected'));
      if (found.classList.contains('tool')) found.classList.add('selected');
      if (found.classList.contains('color-swatch')) found.style.outline = '2px solid var(--panel-accent)';
    } else {
      // stayed: if >500ms, select
      if (performance.now() - selectionHoverStart > 500){
        applyUISelection(found);
        // prevent immediate re-trigger
        selectionHoverStart = performance.now() + 400;
      }
    }
  } else {
    // clear highlights
    const elems2 = [...panel.querySelectorAll('.tool,.color-swatch')];
    elems2.forEach(e=>{
      e.classList && e.classList.remove('selected');
      if (e.classList.contains('color-swatch')) e.style.outline = 'none';
    });
    hoverTarget = null;
    selectionHoverStart = null;
  }
}

function applyUISelection(el){
  if (!el) return;
  if (el.id === 'clearBtn'){
    // clear draw canvas (with fade)
    ctxDraw.clearRect(0,0,drawCanvas.width,drawCanvas.height);
    return;
  }
  if (el.classList.contains('tool')){
    selectedTool = el.dataset.tool;
    toolPen.classList.toggle('selected', selectedTool === 'pen');
    toolEraser.classList.toggle('selected', selectedTool === 'eraser');
    statusEl.textContent = 'çŠ¶æ€ï¼šå·²é€‰æ‹© ' + (selectedTool === 'pen' ? 'ç¬”' : 'æ©¡çš®');
    return;
  }
  if (el.classList.contains('color-swatch')){
    selectedColor = el.dataset.color;
    colorSwatches.forEach(s=>s.style.outline = 'none');
    el.style.outline = '2px solid var(--panel-accent)';
    statusEl.textContent = 'çŠ¶æ€ï¼šå·²é€‰æ‹©é¢œè‰² ' + selectedColor;
    return;
  }
  if (el.id === 'sizeRange'){
    // size handled automatically on change events
  }
}

/* ---------- Drawing ç®¡ç† ---------- */
function screenToCanvasXY(nx, ny){
  // nx,ny are normalized coords relative to video (0..1)
  return {x: nx * drawCanvas.width, y: ny * drawCanvas.height};
}

function startDrawingAt(pt){
  drawing = true;
  lastDrawPoint = pt;
}

function stopDrawing(){
  drawing = false;
  lastDrawPoint = null;
}

function drawLineTo(pt){
  if (!lastDrawPoint) lastDrawPoint = pt;
  ctxDraw.save();
  ctxDraw.globalCompositeOperation = (selectedTool === 'eraser') ? 'destination-out' : 'source-over';
  ctxDraw.lineCap = 'round';
  ctxDraw.lineJoin = 'round';
  ctxDraw.strokeStyle = selectedTool === 'eraser' ? 'rgba(0,0,0,1)' : selectedColor;
  ctxDraw.lineWidth = penSize;
  ctxDraw.beginPath();
  ctxDraw.moveTo(lastDrawPoint.x, lastDrawPoint.y);
  ctxDraw.lineTo(pt.x, pt.y);
  ctxDraw.stroke();
  ctxDraw.restore();
  lastDrawPoint = pt;
}

/* ---------- Disperseï¼ˆé›ªèŠ±ï¼‰æ•ˆæœ ---------- */
function startDisperse(){
  if (dispersing) return;
  // sample non-transparent pixels from drawCanvas
  const w = drawCanvas.width, h = drawCanvas.height;
  const imageData = ctxDraw.getImageData(0,0,w,h);
  const data = imageData.data;
  const pts = [];
  // sample with stride to control particle count
  const stride = 6; // increase -> fewer particles
  for (let y=0; y<h; y+=stride){
    for (let x=0; x<w; x+=stride){
      const idx = (y*w + x) * 4;
      const alpha = data[idx+3];
      if (alpha > 50){
        pts.push({x,y, color: `rgba(${data[idx]},${data[idx+1]},${data[idx+2]},${data[idx+3]/255})`});
      }
    }
  }
  // choose up to N particles
  const N = Math.min(900, pts.length);
  particles = [];
  for (let i=0;i<N;i++){
    const p = pts[Math.floor(Math.random()*pts.length)];
    particles.push({
      x: p.x,
      y: p.y,
      vx: (Math.random()-0.5)*0.4 + (Math.random()-0.5)*1.0,
      vy: Math.random()*0.6 + 0.6,
      life: 1.0,
      color: p.color,
      size: Math.random()*3 + 1
    });
  }
  // clear draw canvas to "release" them
  ctxDraw.clearRect(0,0,w,h);
  dispersing = true;
  statusEl.textContent = 'çŠ¶æ€ï¼šæ¶ˆæ•£ä¸­...';
}

function updateParticles(dt){
  if (!dispersing) return;
  const w = drawCanvas.width, h = drawCanvas.height;
  for (const p of particles){
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    p.vy += 0.002 * dt * 60;
    p.life -= 0.0015 * dt * 60;
  }
  // remove dead
  particles = particles.filter(p=>p.life > 0 && p.y < h + 30);
  if (particles.length === 0){
    dispersing = false;
    statusEl.textContent = 'çŠ¶æ€ï¼šç­‰å¾…æ‰‹åŠ¿';
  }
}

function drawParticles(){
  if (!dispersing) return;
  ctxOverlay.save();
  for (const p of particles){
    ctxOverlay.globalAlpha = Math.max(0,p.life);
    ctxOverlay.beginPath();
    ctxOverlay.fillStyle = p.color;
    ctxOverlay.arc(p.x, p.y, p.size, 0, Math.PI*2);
    ctxOverlay.fill();
  }
  ctxOverlay.restore();
}

/* ---------- MediaPipe Hands setup ---------- */
const hands = new Hands({locateFile: (file) => {
  return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});
hands.setOptions({
  maxNumHands: 2,
  modelComplexity: 1,
  minDetectionConfidence: 0.6,
  minTrackingConfidence: 0.5
});

hands.onResults(onHandsResults);

const camera = new Camera(video, {
  onFrame: async () => {
    await hands.send({image: video});
  },
  width: 1280,
  height: 720
});
camera.start();

/* ---------- ä¸»å¤„ç†å›è°ƒ ---------- */
let lastTime = performance.now();

function onHandsResults(results){
  // ensure canvases sized
  if (video.videoWidth && video.videoHeight){
    if (overlay.width !== video.videoWidth || overlay.height !== video.videoHeight){
      resizeCanvasesToVideo();
    }
  }

  // clear overlay each frame
  ctxOverlay.clearRect(0,0,overlay.width,overlay.height);

  const now = performance.now();
  const dt = now - lastTime;
  lastTime = now;

  // draw existing drawing (drawCanvas) on overlay with globalScale transform
  // We'll draw drawCanvas onto overlay before overlay drawings so overlay can show particles and gesture markers
  ctxOverlay.save();
  ctxOverlay.setTransform(globalScale, 0, 0, globalScale, (1-globalScale)*overlay.width/2, (1-globalScale)*overlay.height/2);
  ctxOverlay.drawImage(drawCanvas, 0, 0);
  ctxOverlay.restore();

  // process hands
  const multiHandLandmarks = results.multiHandLandmarks || [];
  const multiHandedness = results.multiHandedness || []; // info about left/right
  // mirror coordinates horizontally for intuitive mapping (because video mirrored)
  // MediaPipe returns normalized (0..1) coords in results, with origin at top-left of image.
  // We'll mirror x by x' = 1 - x for our UI coordinates (so displayed matches user's mirror).
  // For ease: create processed array of hands with normalized landmarks mirrored
  const handsData = multiHandLandmarks.map((lm, idx) => {
    const mirrored = lm.map(p => ({x: 1 - p.x, y: p.y, z: p.z}));
    return {landmarks: mirrored, handedness: (multiHandedness[idx] && multiHandedness[idx].label) || 'Unknown'};
  });

  // If any hand shows full palm open -> show panel near that hand (the first)
  let palmHand = null;
  for (const h of handsData){
    if (isPalmOpen(h.landmarks)){
      palmHand = h;
      break;
    }
  }

  if (palmHand && !panelVisible){
    // show panel near wrist or palm center
    const wrist = palmHand.landmarks[0];
    const px = wrist.x; const py = wrist.y;
    // position in normalized container coords, but we need mirrored mapping to CSS (video mirrored)
    showPanelAt(px, py);
    statusEl.textContent = 'çŠ¶æ€ï¼šé¢æ¿å·²å‘¼å‡ºï¼Œé£ŸæŒ‡æŒ‡å‘é€‰æ‹©';
  } else if (!palmHand && panelVisible){
    // if panel visible and palm not detected, leave it until palm reappears to close
    // But user spec: "é€‰æ‹©å®Œç›¸åº”åŠŸèƒ½åï¼Œæ£€æµ‹åˆ°æ•´ä¸ªæ‰‹æŒåé€€å‡ºUIé¢æ¿" -> so close panel when a palm is detected AFTER selection
    // We'll close panel when a palm is detected and selection made (status changed). For simplicity, if panel visible and we detect a palm again, we close.
    // Here we keep panel until explicit palm close handled below.
  }

  // If panel visible and hand present, compute index finger pos to hover/select
  if (panelVisible && handsData.length > 0){
    const primary = handsData[0];
    const idxTip = primary.landmarks[8]; // normalized mirrored
    updatePanelHover(idxTip.x, idxTip.y, overlay.width, overlay.height);
    // draw indicator
    const p = screenToCanvasXY(idxTip.x, idxTip.y);
    ctxOverlay.beginPath();
    ctxOverlay.fillStyle = 'rgba(255,255,255,0.9)';
    ctxOverlay.arc(p.x, p.y, 6, 0, Math.PI*2);
    ctxOverlay.fill();
  }

  // If panel visible and we detect a full palm again (after some selection), close it
  if (panelVisible && palmHand){
    // close panel
    hidePanel();
    statusEl.textContent = 'çŠ¶æ€ï¼šé¢æ¿å·²å…³é—­';
  }

  // Gesture: drawing (pinch) on any hand
  let pinchHand = null;
  for (const h of handsData){
    if (isPinch(h.landmarks, overlay.width, overlay.height)){
      pinchHand = h;
      break;
    }
  }

  if (pinchHand){
    // get index tip pos
    const nt = pinchHand.landmarks[8];
    const pt = screenToCanvasXY(nt.x, nt.y);
    if (!drawing){
      // start drawing
      startDrawingAt(pt);
      statusEl.textContent = 'çŠ¶æ€ï¼šç»˜åˆ¶ä¸­';
    } else {
      drawLineTo(pt);
    }
  } else {
    if (drawing){
      stopDrawing();
      statusEl.textContent = 'çŠ¶æ€ï¼šç»˜åˆ¶å®Œæˆ';
    }
  }

  // two-hand index scaling: require two hands present and both have index extended
  if (handsData.length >= 2){
    const h1 = handsData[0], h2 = handsData[1];
    const f1 = fingersExtended(h1.landmarks);
    const f2 = fingersExtended(h2.landmarks);
    if (f1.index && f2.index && !twoHandScaling.active && !dispersing){
      // start scaling
      twoHandScaling.active = true;
      twoHandScaling.startDist = dist({x:h1.landmarks[8].x,y:h1.landmarks[8].y},{x:h2.landmarks[8].x,y:h2.landmarks[8].y});
      twoHandScaling.startScale = globalScale;
      statusEl.textContent = 'çŠ¶æ€ï¼šåŒæ‰‹ç¼©æ”¾ä¸­';
    } else if (twoHandScaling.active){
      if (f1.index && f2.index){
        const curDist = dist({x:h1.landmarks[8].x,y:h1.landmarks[8].y},{x:h2.landmarks[8].x,y:h2.landmarks[8].y});
        const factor = curDist / twoHandScaling.startDist;
        globalScale = Math.min(4, Math.max(0.3, twoHandScaling.startScale * factor));
      } else {
        twoHandScaling.active = false;
        statusEl.textContent = 'çŠ¶æ€ï¼šç­‰å¾…æ‰‹åŠ¿';
      }
    }
  } else {
    twoHandScaling.active = false;
  }

  // Disperse trigger: if any hand has index+middle open simultaneously (as requested)
  if (!dispersing){
    for (const h of handsData){
      if (isIndexAndMiddleOpen(h.landmarks)){
        // start disperse
        startDisperse();
        break;
      }
    }
  }

  // draw hand landmarks for debugging / UX
  drawHandsOverlay(handsData);

  // update particles animation
  updateParticles(dt);
  drawParticles();

  // draw status overlay
  ctxOverlay.fillStyle = 'rgba(255,255,255,0.06)';
  ctxOverlay.fillRect(8,8,0.5,0.5); // nothing, placeholder

  // request next repaint (particles animate by requestAnimationFrame)
}

/* ---------- æ¸²æŸ“æ‰‹éƒ¨ç®€è¦éª¨æ¶å’ŒæŒ‡ç¤º ---------- */
function drawHandsOverlay(handsData){
  ctxOverlay.save();
  ctxOverlay.lineWidth = 2;
  for (const h of handsData){
    const lm = h.landmarks;
    // draw landmarks
    for (let i=0;i<lm.length;i++){
      const p = screenToCanvasXY(lm[i].x, lm[i].y);
      ctxOverlay.beginPath();
      ctxOverlay.fillStyle = 'rgba(255,255,255,0.7)';
      ctxOverlay.arc(p.x, p.y, 4,0,Math.PI*2);
      ctxOverlay.fill();
    }
    // draw connections for index and thumb for clarity
    const idxTip = screenToCanvasXY(lm[8].x, lm[8].y);
    const thumbTip = screenToCanvasXY(lm[4].x, lm[4].y);
    ctxOverlay.beginPath();
    ctxOverlay.moveTo(idxTip.x, idxTip.y);
    ctxOverlay.lineTo(thumbTip.x, thumbTip.y);
    ctxOverlay.strokeStyle = 'rgba(255,255,255,0.18)';
    ctxOverlay.stroke();
    // show bounding palm center
    const cx = (lm[0].x+lm[9].x+lm[5].x)/3;
    const cy = (lm[0].y+lm[9].y+lm[5].y)/3;
    const cp = screenToCanvasXY(cx,cy);
    ctxOverlay.beginPath();
    ctxOverlay.fillStyle = 'rgba(255,255,255,0.06)';
    ctxOverlay.arc(cp.x, cp.y, 18,0,Math.PI*2);
    ctxOverlay.fill();
    // If panel visible, draw a connector line to panel
    if (panelVisible){
      const panelRect = panel.getBoundingClientRect();
      const containerRect = document.getElementById('container').getBoundingClientRect();
      const panelX = (panelRect.left + panelRect.width/2 - containerRect.left) / containerRect.width;
      const panelY = (panelRect.top + panelRect.height/2 - containerRect.top) / containerRect.height;
      const pPanel = screenToCanvasXY(panelX, panelY);
      ctxOverlay.beginPath();
      ctxOverlay.moveTo(cp.x, cp.y);
      ctxOverlay.lineTo(pPanel.x, pPanel.y);
      ctxOverlay.strokeStyle = 'rgba(110,231,183,0.18)';
      ctxOverlay.stroke();
    }
  }
  ctxOverlay.restore();
}

/* ---------- UI events ---------- */
sizeRange.addEventListener('input', (e)=>{
  penSize = +e.target.value;
  sizeValue.textContent = penSize;
});
toolPen.addEventListener('click', ()=>{ selectedTool='pen'; applyUISelection(toolPen);});
toolEraser.addEventListener('click', ()=>{ selectedTool='eraser'; applyUISelection(toolEraser);});
colorSwatches.forEach(s=>{
  s.addEventListener('click', ()=>{ selectedColor = s.dataset.color; applyUISelection(s);});
});
clearBtn.addEventListener('click', ()=>{ applyUISelection(clearBtn); });

/* ---------- animation loop to keep particles moving and overlay updated ---------- */
function animate(){
  const now = performance.now();
  const dt = (now - (animate._last || now)) / (1000/60); // normalize roughly to 60fps units
  animate._last = now;
  // clear overlay and redraw the persistent drawCanvas with transform applied to overlay,
  // plus particles (these are drawn in onHandsResults too). This animate loop ensures particles move between frames even when no hands updated.
  if (dispersing){
    ctxOverlay.clearRect(0,0,overlay.width,overlay.height);
    updateParticles(dt);
    drawParticles();
  }
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

/* ---------- å¯åŠ¨æ‘„åƒå¤´åï¼Œè°ƒæ•´å¤§å° ---------- */
video.addEventListener('loadeddata', ()=>{
  resizeCanvasesToVideo();
});

/* ---------- å‹å¥½æç¤ºï¼šå¦‚æœæ‘„åƒå¤´æƒé™è¢«æ‹’ç» ---------- */
navigator.mediaDevices.getUserMedia({video:true}).then(s=>{ /* do nothing: Camera started above */ }).catch(err=>{
  alert('è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥ä½¿ç”¨æ­¤ç¤ºä¾‹ã€‚\né”™è¯¯ï¼š' + err.message);
});

/* ---------- ç»“æŸ ---------- */
</script>
</body>
</html>
