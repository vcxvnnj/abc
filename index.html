<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI éš”ç©ºæ‰‹åŠ¿ç”»æ¿</title>
    <!-- å¼•å…¥ Tailwind CSS è¿›è¡Œå¿«é€Ÿæ ·å¼å¸ƒå±€ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        /* è§†é¢‘å±‚éšè—ï¼Œæˆ‘ä»¬åªåœ¨Canvasä¸Šç»˜åˆ¶å¤„ç†åçš„ç”»é¢ */
        #input_video { display: none; }
        /* ä¸»ç”»å¸ƒï¼Œè¦†ç›–å…¨å± */
        #output_canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            transform: scaleX(-1); /* é•œåƒæ˜¾ç¤º */
        }
        /* UIå±‚ï¼Œä¸ç¿»è½¬ï¼Œæ–¹ä¾¿é˜…è¯»æ–‡å­— */
        #ui_overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€ï¼Œå®Œå…¨é æ‰‹åŠ¿æ§åˆ¶ */
        }
        
        .loading-screen {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: #111;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: opacity 0.5s;
        }

        /* è™šæ‹Ÿèœå•é¢æ¿æ ·å¼ */
        .virtual-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 400px;
            background: rgba(20, 20, 20, 0.9);
            border: 2px solid #00d2ff;
            border-radius: 20px;
            padding: 20px;
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.3);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            pointer-events: none; /* é€»è¾‘æ£€æµ‹ï¼Œä¸é é¼ æ ‡ */
        }

        .virtual-menu.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }

        .menu-item {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            color: white;
            border: 2px solid transparent;
            transition: all 0.2s;
        }

        .menu-item.hovered {
            background: rgba(0, 210, 255, 0.3);
            border-color: #00d2ff;
            transform: scale(1.05);
        }

        .menu-item.selected {
            background: #00d2ff;
            color: black;
            font-weight: bold;
        }

        .color-dot {
            width: 30px; 
            height: 30px; 
            border-radius: 50%; 
            display: inline-block;
            border: 2px solid white;
        }

        /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
        #status_bar {
            position: absolute;
            top: 20px;
            right: 20px; /* å› ä¸ºç”»å¸ƒé•œåƒï¼Œå®é™…åœ¨å·¦è¾¹ï¼Œè¿™é‡Œæˆ‘ä»¬åœ¨CSSé‡Œä¸ç¿»è½¬UIå±‚ */
            background: rgba(0,0,0,0.6);
            padding: 10px 20px;
            border-radius: 20px;
            color: #fff;
            font-size: 14px;
            pointer-events: none;
        }
        
        .gesture-hint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.7);
            font-size: 12px;
            text-align: center;
            width: 100%;
        }
    </style>
</head>
<body>

    <!-- åŠ è½½ç•Œé¢ -->
    <div id="loading" class="loading-screen">
        <div class="text-2xl font-bold mb-4">ğŸ– AI æ‰‹åŠ¿ç”»æ¿</div>
        <div class="text-sm text-gray-400">æ­£åœ¨åŠ è½½æ¨¡å‹... (é¦–æ¬¡åŠ è½½å¯èƒ½éœ€è¦å‡ åç§’)</div>
        <div class="mt-4 text-xs text-gray-500">è¯·æˆäºˆæ‘„åƒå¤´æƒé™</div>
    </div>

    <!-- åŸå§‹è§†é¢‘è¾“å…¥ (éšè—) -->
    <video id="input_video" playsinline></video>

    <!-- ç»˜åˆ¶å±‚ (é•œåƒ) -->
    <canvas id="output_canvas"></canvas>

    <!-- UI äº¤äº’å±‚ (ä¸é•œåƒ) -->
    <div id="ui_overlay">
        <div id="status_bar">
            å½“å‰å·¥å…·: <span id="current_tool" class="text-blue-400 font-bold">ç”»ç¬”</span> | 
            çŠ¶æ€: <span id="gesture_state">ç­‰å¾…æ‰‹åŠ¿...</span>
        </div>

        <!-- è™šæ‹Ÿèœå• -->
        <div id="menu_panel" class="virtual-menu">
            <div class="col-span-2 text-center text-white mb-2 font-bold border-b border-gray-600 pb-2">å·¥å…·ç®± (é£ŸæŒ‡é€‰æ‹©)</div>
            
            <div class="menu-item" data-action="tool_pen">
                <div class="text-xl mb-1">âœï¸</div>
                <div>ç”»ç¬”</div>
            </div>
            <div class="menu-item" data-action="tool_eraser">
                <div class="text-xl mb-1">ğŸ§¹</div>
                <div>æ©¡çš®æ“¦</div>
            </div>

            <div class="col-span-2 text-center text-xs text-gray-400 mt-2">é¢œè‰²</div>
            <div class="menu-item" data-action="color_red">
                <div class="color-dot" style="background: #ff4444;"></div>
            </div>
            <div class="menu-item" data-action="color_green">
                <div class="color-dot" style="background: #44ff44;"></div>
            </div>
            <div class="menu-item" data-action="color_blue">
                <div class="color-dot" style="background: #4444ff;"></div>
            </div>
            <div class="menu-item" data-action="color_white">
                <div class="color-dot" style="background: #ffffff;"></div>
            </div>

            <div class="col-span-2 text-center text-xs text-gray-400 mt-2">ç²—ç»†</div>
            <div class="menu-item" data-action="size_small">
                <div class="w-full h-1 bg-white rounded"></div>
                <div class="text-xs mt-1">ç»†</div>
            </div>
            <div class="menu-item" data-action="size_large">
                <div class="w-full h-3 bg-white rounded"></div>
                <div class="text-xs mt-1">ç²—</div>
            </div>
        </div>

        <div class="gesture-hint">
            ğŸ‘Œ æåˆå†™å­— | âœ‹ å¼ å¼€æ‰‹æŒå”¤èµ·èœå• | âœŒï¸ å‰ªåˆ€æ‰‹æ¸…å±(é›ªèŠ±) | â˜ï¸â˜ï¸ åŒæ‰‹ç¼©æ”¾
        </div>
    </div>

    <script>
        // ================= é…ç½®ä¸å˜é‡ =================
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const uiOverlay = document.getElementById('ui_overlay');
        const menuPanel = document.getElementById('menu_panel');
        const statusBarTool = document.getElementById('current_tool');
        const statusBarState = document.getElementById('gesture_state');

        // åº”ç”¨çŠ¶æ€
        let state = {
            isMenuOpen: false,
            currentTool: 'pen', // 'pen', 'eraser'
            currentColor: '#ffffff',
            currentSize: 5,
            menuCooldown: 0, // é˜²æ­¢èœå•é¢‘ç¹å¼€å…³çš„å†·å´å¸§
            drawing: false,
            scale: 1, // ç”»å¸ƒç¼©æ”¾æ¯”ä¾‹
            pan: { x: 0, y: 0 }, // ç”»å¸ƒå¹³ç§» (æš‚æœªå®ç°å®Œå…¨å¹³ç§»ï¼Œä¸»è¦ç”¨äºç¼©æ”¾ä¸­å¿ƒ)
            lastPinchDist: null, // ç”¨äºåŒæŒ‡ç¼©æ”¾è®¡ç®—
        };

        // ç¬”ç”»æ•°æ®
        // ç»“æ„: [ { points: [{x,y}, ...], color, size, isEraser } ]
        let strokes = [];
        let currentStroke = [];

        // ç²’å­ç³»ç»Ÿ (é›ªèŠ±æ•ˆæœ)
        let particles = [];
        let isExploding = false;

        // æ‰‹åŠ¿é˜ˆå€¼
        const THRESHOLD_PINCH = 0.05; // æåˆè·ç¦»
        const THRESHOLD_MENU_HOVER = 40; // èœå•æ‚¬åœåƒç´ è·ç¦»
        const MENU_SELECTION_TIME = 20; // æ‚¬åœå¤šå°‘å¸§åé€‰ä¸­
        let menuHoverCounter = 0;
        let lastHoveredAction = null;

        // Canvas å°ºå¯¸åˆå§‹åŒ–
        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        // ================= ç²’å­ç³»ç»Ÿ (é›ªèŠ±æ¶ˆæ•£) =================
        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.vx = (Math.random() - 0.5) * 4; // æ°´å¹³éšæœºæ¼‚ç§»
                this.vy = Math.random() * 2 + 1; // å‚ç›´ä¸‹è½
                this.alpha = 1;
                this.size = Math.random() * 3 + 1;
                this.decay = Math.random() * 0.02 + 0.005; // æ¶ˆå¤±é€Ÿåº¦
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vx *= 0.95; // ç©ºæ°”é˜»åŠ›
                this.alpha -= this.decay;
            }
            draw(ctx) {
                ctx.globalAlpha = this.alpha;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        function triggerSnowEffect() {
            if (strokes.length === 0) return;
            
            // å°†æ‰€æœ‰ç¬”ç”»è½¬åŒ–ä¸ºç²’å­
            strokes.forEach(stroke => {
                // é‡‡æ ·ç‚¹ä»¥å‡å°‘æ€§èƒ½å‹åŠ›ï¼Œæ¯éš”å‡ ä¸ªç‚¹å–ä¸€ä¸ª
                for (let i = 0; i < stroke.points.length; i += 2) {
                    const p = stroke.points[i];
                    // åº”ç”¨å½“å‰çš„ç¼©æ”¾è½¬æ¢åæ ‡
                    const screenX = (p.x * canvasElement.width) * state.scale + (canvasElement.width * (1-state.scale)/2);
                    const screenY = (p.y * canvasElement.height) * state.scale + (canvasElement.height * (1-state.scale)/2);
                    
                    particles.push(new Particle(screenX, screenY, stroke.isEraser ? '#000' : stroke.color));
                }
            });

            strokes = []; // æ¸…ç©ºç¬”ç”»
            isExploding = true;
            statusBarState.innerText = "â„ï¸ é›ªèŠ±æ¶ˆæ•£ä¸­...";
        }

        // ================= æ‰‹åŠ¿è¾…åŠ©å‡½æ•° =================
        
        // è®¡ç®—ä¸¤ç‚¹é—´æ¬§å‡ é‡Œå¾—è·ç¦» (æ ‡å‡†åŒ–åæ ‡ 0-1)
        function getDistance(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        // æ£€æµ‹æ‰‹æŒæ˜¯å¦å¼ å¼€ (ç®€å•åˆ¤æ–­ï¼šæ‰‹æŒ‡æ˜¯å¦éƒ½æ¯”è¾ƒç›´ä¸”åˆ†æ•£)
        // è¿™é‡Œç®€åŒ–ä¸ºï¼šæŒ‡å°–ä¸æŒæ ¹(0)çš„è·ç¦»æ¯”è¾ƒè¿œ
        function isHandOpen(landmarks) {
            // æ£€æŸ¥ 8, 12, 16, 20 æŒ‡å°–ä¸ 0 çš„è·ç¦»
            // ç®€å•åˆ¤æ–­ï¼šå¦‚æœæ‰‹æŒ‡æ˜¯å¼¯æ›²çš„ï¼ŒæŒ‡å°–ç¦»æŒæ ¹è¿‘
            // æ›´å¥½çš„æ–¹æ³•ï¼šæ£€æŸ¥æŒ‡å°–(8)æ˜¯å¦åœ¨æŒ‡å…³èŠ‚(6)ä¸Šæ–¹(å¯¹äºç«–ç›´æ‰‹åŠ¿)
            // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªç®€å•çš„æ ‡å¿—ä½åˆ¤æ–­ï¼šå¦‚æœé£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡éƒ½ä¼¸ç›´
            const tips = [8, 12, 16, 20];
            const pips = [6, 10, 14, 18]; // è¿‘æŒ‡èŠ‚
            
            let extendedCount = 0;
            if (getDistance(landmarks[4], landmarks[17]) > 0.15) extendedCount++; // æ‹‡æŒ‡å¼ å¼€
            
            for (let i = 0; i < 4; i++) {
                // æ¯”è¾ƒæŒ‡å°–åˆ°æ‰‹è…•è·ç¦» vs å…³èŠ‚åˆ°æ‰‹è…•è·ç¦»
                if (getDistance(landmarks[tips[i]], landmarks[0]) > getDistance(landmarks[pips[i]], landmarks[0]) * 1.2) {
                    extendedCount++;
                }
            }
            return extendedCount >= 4; // è‡³å°‘4æŒ‡å¼ å¼€
        }

        // æ£€æµ‹å‰ªåˆ€æ‰‹ (é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²)
        function isPeaceSign(landmarks) {
             const tip8 = landmarks[8];
             const pip6 = landmarks[6];
             const tip12 = landmarks[12];
             const pip10 = landmarks[10];
             const tip16 = landmarks[16];
             const pip14 = landmarks[14];
             
             // é£ŸæŒ‡ä¸­æŒ‡ä¼¸ç›´
             const indexOpen = getDistance(tip8, landmarks[0]) > getDistance(pip6, landmarks[0]);
             const middleOpen = getDistance(tip12, landmarks[0]) > getDistance(pip10, landmarks[0]);
             // æ— åæŒ‡å¼¯æ›²
             const ringClosed = getDistance(tip16, landmarks[0]) < getDistance(pip14, landmarks[0]);
             
             // ç®€å•çš„è·ç¦»åˆ¤æ–­ï¼šé£ŸæŒ‡å’Œä¸­æŒ‡åº”è¯¥åˆ†å¼€ä¸€å®šè·ç¦»
             const fingersApart = getDistance(tip8, tip12) > 0.03;

             return indexOpen && middleOpen && ringClosed && fingersApart;
        }

        // æ£€æµ‹æåˆ (æ‹‡æŒ‡ä¸é£ŸæŒ‡)
        function isPinching(landmarks) {
            return getDistance(landmarks[4], landmarks[8]) < THRESHOLD_PINCH;
        }

        // ================= UI äº¤äº’é€»è¾‘ =================
        
        function handleMenuInteraction(indexTipNorm) {
            // å°†å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸ºå±å¹•åæ ‡
            // æ³¨æ„ï¼šCanvasæ˜¯é•œåƒç¿»è½¬çš„ (scaleX(-1))ï¼Œä½† UI å…ƒç´ æ˜¯æ­£å¸¸çš„ã€‚
            // MediaPipe è¾“å‡ºçš„ x æ˜¯ 0(å·¦) -> 1(å³)ã€‚
            // åœ¨é•œåƒæ¨¡å¼ä¸‹ï¼Œæˆ‘ä»¬éœ€è¦ç¿»è½¬ x åæ ‡æ¥å¯¹åº” UI å…ƒç´ çš„ä½ç½®ã€‚
            const screenX = (1 - indexTipNorm.x) * window.innerWidth; 
            const screenY = indexTipNorm.y * window.innerHeight;

            // è·å–æ‰€æœ‰èœå•é¡¹
            const items = document.querySelectorAll('.menu-item');
            let hoveredItem = null;

            items.forEach(item => {
                const rect = item.getBoundingClientRect();
                // ç®€å•çš„çŸ©å½¢ç¢°æ’æ£€æµ‹
                if (screenX >= rect.left && screenX <= rect.right &&
                    screenY >= rect.top && screenY <= rect.bottom) {
                    hoveredItem = item;
                }
                item.classList.remove('hovered'); // æ¸…é™¤ä¹‹å‰çš„æ‚¬åœçŠ¶æ€
            });

            // ç»˜åˆ¶è™šæ‹Ÿå…‰æ ‡åœ¨ UI å±‚ (è§†è§‰åé¦ˆ)
            canvasCtx.save();
            canvasCtx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®å˜æ¢çŸ©é˜µï¼Œä½¿ç”¨ç»å¯¹å±å¹•åæ ‡ç»˜åˆ¶å…‰æ ‡
            canvasCtx.beginPath();
            canvasCtx.arc(screenX, screenY, 10, 0, Math.PI * 2);
            canvasCtx.fillStyle = "rgba(0, 210, 255, 0.7)";
            canvasCtx.fill();
            canvasCtx.restore();

            if (hoveredItem) {
                hoveredItem.classList.add('hovered');
                const action = hoveredItem.getAttribute('data-action');
                
                if (action === lastHoveredAction) {
                    menuHoverCounter++;
                } else {
                    menuHoverCounter = 0;
                    lastHoveredAction = action;
                }

                // è¿›åº¦æ¡æˆ–ç¡®è®¤åé¦ˆ
                statusBarState.innerText = `é€‰ä¸­ä¸­... ${Math.floor((menuHoverCounter/MENU_SELECTION_TIME)*100)}%`;

                if (menuHoverCounter > MENU_SELECTION_TIME) {
                    // ç¡®è®¤é€‰æ‹©
                    executeMenuAction(action);
                    menuHoverCounter = 0;
                    // é€‰æ‹©åçŸ­æš‚éœ‡åŠ¨åé¦ˆ (å¦‚æœè®¾å¤‡æ”¯æŒ)
                    if (navigator.vibrate) navigator.vibrate(50);
                    // å…³é—­èœå•
                    toggleMenu(false);
                }
            } else {
                menuHoverCounter = 0;
                lastHoveredAction = null;
                statusBarState.innerText = "è¯·ç”¨é£ŸæŒ‡é€‰æ‹©";
            }
        }

        function executeMenuAction(action) {
            // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.menu-item').forEach(i => i.classList.remove('selected'));
            const selectedItem = document.querySelector(`.menu-item[data-action="${action}"]`);
            if(selectedItem) selectedItem.classList.add('selected');

            if (action === 'tool_pen') {
                state.currentTool = 'pen';
                statusBarTool.innerText = "ç”»ç¬”";
                statusBarTool.style.color = state.currentColor;
            } else if (action === 'tool_eraser') {
                state.currentTool = 'eraser';
                statusBarTool.innerText = "æ©¡çš®æ“¦";
                statusBarTool.style.color = "#gray";
            } else if (action.startsWith('color_')) {
                const colorMap = {
                    'color_red': '#ff4444',
                    'color_green': '#44ff44',
                    'color_blue': '#4444ff',
                    'color_white': '#ffffff'
                };
                state.currentColor = colorMap[action];
                state.currentTool = 'pen'; // åˆ‡é¢œè‰²è‡ªåŠ¨åˆ‡å›ç¬”
                statusBarTool.innerText = "ç”»ç¬”";
                statusBarTool.style.color = state.currentColor;
            } else if (action === 'size_small') {
                state.currentSize = 3;
            } else if (action === 'size_large') {
                state.currentSize = 10;
            }
        }

        function toggleMenu(isOpen) {
            state.isMenuOpen = isOpen;
            if (isOpen) {
                menuPanel.classList.add('active');
                state.menuCooldown = 30; // å†·å´æ—¶é—´ï¼Œé˜²æ­¢é©¬ä¸Šå…³é—­
            } else {
                menuPanel.classList.remove('active');
                state.menuCooldown = 30;
                menuHoverCounter = 0; // é‡ç½®æ‚¬åœè®¡æ•°
            }
        }

        // ================= MediaPipe å›è°ƒæ ¸å¿ƒ =================
        function onResults(results) {
            // 1. æ¸…ç©ºç”»å¸ƒ
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            
            // ç»˜åˆ¶æ‘„åƒå¤´ç”»é¢ (ä½œä¸ºèƒŒæ™¯)
            // å¿…é¡»åè½¬ç»˜åˆ¶ï¼Œå› ä¸ºæˆ‘ä»¬çš„ Canvas CSS ç¿»è½¬äº†ï¼Œä½† drawImage æ˜¯åŸå§‹çš„
            // ä¸ºäº†è®©ç”»é¢çœ‹èµ·æ¥åƒé•œå­ï¼Œæˆ‘ä»¬éœ€è¦åœ¨ Canvas å†…éƒ¨ä¹Ÿåšä¸€æ¬¡ç¿»è½¬ç»˜åˆ¶ï¼Œæˆ–è€…ç›´æ¥åˆ©ç”¨ CSS çš„ç¿»è½¬ã€‚
            // ç®€å•æ–¹æ¡ˆï¼šCSS ç¿»è½¬äº† canvasï¼Œæ‰€ä»¥æˆ‘ä»¬æ­£å¸¸ drawImageï¼Œç”»é¢å°±æ˜¯é•œåƒçš„ã€‚
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // ç»˜åˆ¶åŠé€æ˜é®ç½©ï¼Œè®©ç”»ç¬”æ›´æ˜æ˜¾
            canvasCtx.fillStyle = 'rgba(0,0,0,0.3)';
            canvasCtx.fillRect(0,0, canvasElement.width, canvasElement.height);

            // å¤„ç†å†·å´æ—¶é—´
            if (state.menuCooldown > 0) state.menuCooldown--;

            // 2. ç²’å­åŠ¨ç”» (å¦‚æœå¤„äºæ¶ˆæ•£çŠ¶æ€)
            if (isExploding) {
                let aliveParticles = false;
                particles.forEach(p => {
                    p.update();
                    p.draw(canvasCtx);
                    if (p.alpha > 0) aliveParticles = true;
                });
                
                // æ¸…ç†æ­»äº¡ç²’å­
                if (!aliveParticles) {
                    particles = [];
                    isExploding = false;
                    statusBarState.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                }
            }

            // 3. å¤„ç†æ‰‹éƒ¨æ£€æµ‹
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                // --- åŒæ‰‹ç¼©æ”¾é€»è¾‘ ---
                if (results.multiHandLandmarks.length === 2 && !state.isMenuOpen) {
                    const hand1 = results.multiHandLandmarks[0][8]; // é£ŸæŒ‡
                    const hand2 = results.multiHandLandmarks[1][8];
                    const dist = getDistance(hand1, hand2);
                    
                    if (state.lastPinchDist) {
                        const delta = dist - state.lastPinchDist;
                        state.scale += delta * 1.5; // çµæ•åº¦ç³»æ•°
                        state.scale = Math.max(0.5, Math.min(state.scale, 3.0)); // é™åˆ¶ç¼©æ”¾èŒƒå›´
                        statusBarState.innerText = `ğŸ” ç¼©æ”¾: ${(state.scale * 100).toFixed(0)}%`;
                    }
                    state.lastPinchDist = dist;
                    
                    // ç»˜åˆ¶ç¼©æ”¾æŒ‡ç¤ºçº¿
                    const x1 = hand1.x * canvasElement.width;
                    const y1 = hand1.y * canvasElement.height;
                    const x2 = hand2.x * canvasElement.width;
                    const y2 = hand2.y * canvasElement.height;
                    canvasCtx.beginPath();
                    canvasCtx.moveTo(x1, y1);
                    canvasCtx.lineTo(x2, y2);
                    canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                    canvasCtx.setLineDash([5, 5]);
                    canvasCtx.stroke();
                    canvasCtx.setLineDash([]);
                } else {
                    state.lastPinchDist = null;
                }

                // --- å•æ‰‹/ä¸»æ‰‹é€»è¾‘ (åªå–ç¬¬ä¸€åªæ‰‹ä½œä¸ºä¸»æ§) ---
                const landmarks = results.multiHandLandmarks[0];
                const indexTip = landmarks[8];
                
                // 3.1 ç»˜åˆ¶æ‰‹éƒ¨å…³é”®ç‚¹ (è°ƒè¯•ç”¨ï¼Œå¯é€‰)
                drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
                
                // 3.2 èœå•å¼€å…³æ£€æµ‹ (æ‰‹æŒå¼ å¼€)
                if (state.menuCooldown === 0) {
                    const handOpen = isHandOpen(landmarks);
                    if (handOpen && !state.isMenuOpen) {
                        toggleMenu(true);
                        statusBarState.innerText = "èœå•å·²æ‰“å¼€";
                    } else if (handOpen && state.isMenuOpen) {
                        toggleMenu(false);
                        statusBarState.innerText = "èœå•å·²å…³é—­";
                    }
                }

                // 3.3 å‰ªåˆ€æ‰‹æ¶ˆæ•£æ£€æµ‹
                if (isPeaceSign(landmarks) && !state.isMenuOpen && !isExploding) {
                    triggerSnowEffect();
                }

                // 3.4 çŠ¶æ€åˆ†å‘
                if (state.isMenuOpen) {
                    // --- èœå•æ¨¡å¼ ---
                    handleMenuInteraction(indexTip);
                } else {
                    // --- ç»˜å›¾æ¨¡å¼ ---
                    // æ£€æŸ¥æ˜¯å¦æåˆ (å†™å­—)
                    if (isPinching(landmarks)) {
                        state.drawing = true;
                        statusBarState.innerText = state.currentTool === 'eraser' ? "ğŸ§¹ æ“¦é™¤ä¸­..." : "âœï¸ ä¹¦å†™ä¸­...";
                        
                        // è®°å½•ç¬”ç”»ç‚¹ (å­˜å½’ä¸€åŒ–åæ ‡ï¼Œæ¸²æŸ“æ—¶å†åº”ç”¨ç¼©æ”¾)
                        // æ³¨æ„ï¼šä¸ºäº†è®©ä¹¦å†™è·Ÿéšæ‰‹æŒ‡åœ¨ç¼©æ”¾åçš„ç”»å¸ƒä¸Šçš„ä½ç½®ï¼Œéœ€è¦åæ¨åæ ‡
                        // ç®€åŒ–é€»è¾‘ï¼šæˆ‘ä»¬å­˜å‚¨åŸå§‹ç›¸å¯¹åæ ‡ï¼Œæ¸²æŸ“æ—¶åº”ç”¨ç»Ÿä¸€çš„ transform
                        // ä¿®æ­£ï¼šå¦‚æœæˆ‘ä»¬åœ¨ç¼©æ”¾çŠ¶æ€ä¸‹å†™å­—ï¼Œæ–°å¢çš„ç¬”ç”»åº”è¯¥è®°å½•åœ¨ç›¸å¯¹äº"ä¸–ç•Œ"çš„ä½ç½®
                        // è¿™é‡Œç®€åŒ–å¤„ç†ï¼šä¸åç®—ï¼Œç›´æ¥å­˜ï¼Œä½†è¿™æ ·ç¼©æ”¾åå†™å­—ä¼šæœ‰è§†è§‰åå·®ã€‚
                        // ä¸ºäº†ä½“éªŒæœ€ä½³ï¼šå»ºè®®å†™å­—æ—¶é‡ç½®ç¼©æ”¾ï¼Œæˆ–åªå…è®¸ 1.0 å€ç‡ä¸‹å†™å­—ã€‚
                        // æœ¬ä»£ç é‡‡ç”¨æ–¹æ¡ˆï¼šå­˜å‚¨å½’ä¸€åŒ–åæ ‡ï¼Œæ¸²æŸ“æ—¶ç»Ÿä¸€ä¹˜ Scaleã€‚
                        
                        currentStroke.push({ x: indexTip.x, y: indexTip.y });
                    } else {
                        // æŠ¬èµ·ç¬”
                        if (state.drawing) {
                            state.drawing = false;
                            statusBarState.innerText = "ç­‰å¾…æ‰‹åŠ¿...";
                            // ä¿å­˜è¿™ä¸€ç¬”
                            if (currentStroke.length > 0) {
                                strokes.push({
                                    points: [...currentStroke],
                                    color: state.currentColor,
                                    size: state.currentSize,
                                    isEraser: state.currentTool === 'eraser'
                                });
                                currentStroke = [];
                            }
                        }
                    }
                    
                    // ç»˜åˆ¶ç¬”å°–å…‰æ ‡
                    const cursorX = indexTip.x * canvasElement.width;
                    const cursorY = indexTip.y * canvasElement.height;
                    canvasCtx.beginPath();
                    canvasCtx.arc(cursorX, cursorY, 5, 0, Math.PI * 2);
                    canvasCtx.fillStyle = isPinching(landmarks) ? '#ff0000' : '#ffff00';
                    canvasCtx.fill();
                }
            }

            // 4. æ¸²æŸ“æ‰€æœ‰ç¬”ç”»
            // åº”ç”¨ä¸­å¿ƒç¼©æ”¾å˜æ¢
            canvasCtx.save();
            // ç®€å•çš„ä¸­å¿ƒç¼©æ”¾çŸ©é˜µ
            const centerX = canvasElement.width / 2;
            const centerY = canvasElement.height / 2;
            
            canvasCtx.translate(centerX, centerY);
            canvasCtx.scale(state.scale, state.scale);
            canvasCtx.translate(-centerX, -centerY);

            // ç»˜åˆ¶å†å²ç¬”ç”»
            strokes.forEach(stroke => {
                drawStroke(stroke.points, stroke.color, stroke.size, stroke.isEraser);
            });
            // ç»˜åˆ¶å½“å‰æ­£åœ¨ç”»çš„ä¸€ç¬”
            if (currentStroke.length > 0) {
                drawStroke(currentStroke, state.currentColor, state.currentSize, state.currentTool === 'eraser');
            }

            canvasCtx.restore();
            canvasCtx.restore();
        }

        function drawStroke(points, color, size, isEraser) {
            if (points.length < 2) return;

            canvasCtx.beginPath();
            canvasCtx.lineCap = 'round';
            canvasCtx.lineJoin = 'round';
            canvasCtx.lineWidth = size;

            if (isEraser) {
                // æ©¡çš®æ“¦æ¨¡å¼ï¼šä½¿ç”¨ destination-out æˆ–è€…ç»˜åˆ¶èƒŒæ™¯è‰²
                // ç”±äºæœ‰èƒŒæ™¯è§†é¢‘ï¼Œç›´æ¥ç»˜åˆ¶é¢œè‰²ä¸å¤ªè¡Œï¼ŒglobalCompositeOperation æ˜¯æ­£è§£
                // ä½†å› ä¸ºæˆ‘ä»¬æ˜¯ä¸€å¸§å¸§é‡ç»˜ï¼Œå¯ä»¥ç›´æ¥ç”¨é€æ˜æ¸…é™¤ï¼Œæˆ–è€…ç®€å•çš„ç»˜åˆ¶æˆç‰¹æ®Šçš„æ ‡è®°
                // åœ¨è¿™ä¸ªå®æ—¶é‡ç»˜é€»è¾‘é‡Œï¼ŒEraser å®é™…ä¸Šæ˜¯ä¸ªè¦†ç›–å±‚ã€‚
                // æ›´å¥½çš„æ–¹å¼æ˜¯é€»è¾‘ä¸Šåˆ é™¤ç‚¹ï¼Œä½†è®¡ç®—å¤æ‚ã€‚
                // è¿™é‡Œç”¨ç®€åŒ–çš„ "é»‘è‰²/é€æ˜è‰²" è¦†ç›–æ¨¡æ‹Ÿæ©¡çš®æ“¦ (è§†è§‰ä¸Š)ï¼Œ
                // ä½†å› ä¸ºèƒŒæ™¯æ˜¯è§†é¢‘ï¼Œç”»é»‘è‰²ä¼šé®ä½è§†é¢‘ã€‚
                // çœŸæ­£çš„æ©¡çš®æ“¦éœ€è¦ maskingã€‚ä¸ºç®€åŒ–å•æ–‡ä»¶ï¼Œè¿™é‡Œç”¨åŠé€æ˜ç™½è‰²æ¨¡æ‹Ÿ"ä¿®æ­£æ¶²"
                canvasCtx.strokeStyle = "rgba(0,0,0,0.8)"; // å‡è£…æ˜¯ä¿®æ­£å¸¦
            } else {
                canvasCtx.strokeStyle = color;
            }

            canvasCtx.moveTo(points[0].x * canvasElement.width, points[0].y * canvasElement.height);
            for (let i = 1; i < points.length; i++) {
                // ä½¿ç”¨äºŒæ¬¡è´å¡å°”æ›²çº¿ä½¿çº¿æ¡æ›´å¹³æ»‘
                const p1 = points[i-1];
                const p2 = points[i];
                
                // ä¸­ç‚¹
                const midX = (p1.x + p2.x) / 2 * canvasElement.width;
                const midY = (p1.y + p2.y) / 2 * canvasElement.height;
                const endX = p2.x * canvasElement.width;
                const endY = p2.y * canvasElement.height;

                // ç®€å•çš„ç›´çº¿è¿æ¥ (è´å¡å°”ç¨å¾®å¤æ‚ä¸€ç‚¹åœ¨ç‚¹å¾ˆå°‘çš„æ—¶å€™)
                canvasCtx.lineTo(endX, endY);
            }
            canvasCtx.stroke();
        }

        // ================= åˆå§‹åŒ– =================
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2, // å¿…é¡»å¼€å¯åŒæ‰‹ä»¥æ”¯æŒç¼©æ”¾
            modelComplexity: 1, // 1 ä¸ºå¹³è¡¡æ¨¡å¼ï¼Œ0 ä¸ºæé€Ÿï¼ˆé€‚åˆè€æ‰‹æœºï¼‰ï¼Œ2 ä¸ºé«˜ç²¾åº¦
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 1280,
            height: 720,
            facingMode: 'user' // å¼ºåˆ¶ä½¿ç”¨å‰ç½®æ‘„åƒå¤´
        });

        // å¯åŠ¨
        camera.start()
            .then(() => {
                document.getElementById('loading').style.opacity = 0;
                setTimeout(() => document.getElementById('loading').remove(), 500);
                console.log("Camera started");
            })
            .catch(err => {
                console.error(err);
                alert("æ— æ³•å¯åŠ¨æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™æˆ–ä½¿ç”¨ HTTPS/Localhost ç¯å¢ƒ");
            });

    </script>
</body>
</html>

